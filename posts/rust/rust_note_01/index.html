

<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title>Rust | 01. 安装、基础、所有权、结构体、枚举 - JWangL5&#39;s Blog</title><meta name="Description" content=""><meta property="og:title" content="Rust | 01. 安装、基础、所有权、结构体、枚举" />
<meta property="og:description" content="240105 安装和简单上手 安装官网直接下载安装即可，有如下命令行可以使用： rustup updat更新版本 rustup self uninstall卸载 使用 rustc &ndash;versi" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jwangl5.github.io/posts/rust/rust_note_01/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T00:17:49+08:00" />
<meta property="article:modified_time" content="2024-01-07T00:17:49+08:00" />
<meta property="og:see_also" content="https://jwangl5.github.io/posts/rust/rust_note_02/" />


<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Rust | 01. 安装、基础、所有权、结构体、枚举"/>
<meta name="twitter:description" content="240105 安装和简单上手 安装官网直接下载安装即可，有如下命令行可以使用： rustup updat更新版本 rustup self uninstall卸载 使用 rustc &ndash;versi"/>
<meta name="twitter:site" content="@JWangL5"/>
<meta name="application-name" content="JWangL5&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="JWangL5&#39;s Blog">

<meta name="theme-color" content="#f8f8f8"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="canonical" href="https://jwangl5.github.io/posts/rust/rust_note_01/" /><link rel="prev" href="https://jwangl5.github.io/posts/hp_printer/" /><link rel="next" href="https://jwangl5.github.io/posts/rust/rust_note_02/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/color.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><meta name="google-site-verification" content="DrFigam98M993iANGvQ77R9ZkJB3SP8Qqx8Hl3eIK9w" /><meta name="msvalidate.01" content="1EE757E849C4CDADD27165C490982B4E" /><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Rust | 01. 安装、基础、所有权、结构体、枚举",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/jwangl5.github.io\/posts\/rust\/rust_note_01\/"
        },"genre": "posts","wordcount":  7998 ,
        "url": "https:\/\/jwangl5.github.io\/posts\/rust\/rust_note_01\/","datePublished": "2024-01-07T00:17:49+08:00","dateModified": "2024-01-07T00:17:49+08:00","publisher": {
            "@type": "Organization",
            "name": "卢旺"},"authors": [{
                        "@type": "Person",
                        "name": "卢旺"                    
                    }],"description": ""
    }
    </script><script src="//instant.page/5.1.1" defer type="module" integrity="sha384-MWfCL6g1OTGsbSwfuMHc8+8J2u71/LA8dzlIN3ycajckxuZZmF+DNjdm7O6H3PSq"></script>
</head>

<body header-desktop="" header-mobile=""><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark'); window.theme = theme; }
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('' === 'light' || '' === 'dark' || '' === 'black') setTheme(''), saveTheme(''); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="JWangL5&#39;s Blog">JWangL5&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/series/"> 系列 </a><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/galleries/"> 相册 </a><a class="menu-item" href="/about/"> 关于我 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="JWangL5&#39;s Blog">JWangL5&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/series/" title="">系列</a><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/galleries/" title="">相册</a><a class="menu-item" href="/about/" title="">关于我</a><a href="#" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "false")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Rust | 01. 安装、基础、所有权、结构体、枚举</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><span class='author'><i class="author fas fa-user-circle fa-fw"></i><span class='screen-reader-text'>  </span><a href='https://jwangl5.github.io/authors/%E5%8D%A2%E6%97%BA'>卢旺</a></span>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"><i class="far fa-folder fa-fw"></i>编程笔记</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/rust/"><i class="far fa-list-alt fa-fw"></i>Rust语言编程笔记</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2024-01-07">2024-01-07</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2024-01-07">2024-01-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7998 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 16 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="true">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#240105-安装和简单上手"><strong>240105 安装和简单上手</strong></a>
          <ul>
            <li><a href="#安装">安装</a></li>
            <li><a href="#开发工具与代码手动编译">开发工具与代码手动编译</a></li>
            <li><a href="#cargo">Cargo</a></li>
            <li><a href="#猜数游戏代码">猜数游戏代码</a></li>
          </ul>
        </li>
        <li><a href="#240106-通用编程概念"><strong>240106 通用编程概念</strong></a>
          <ul>
            <li><a href="#变量与可变性">变量与可变性</a></li>
            <li><a href="#shadowing隐藏">shadowing（隐藏）</a></li>
            <li><a href="#数据类型">数据类型</a></li>
            <li><a href="#函数">函数</a></li>
            <li><a href="#注释">注释</a></li>
            <li><a href="#控制流程">控制流程</a></li>
          </ul>
        </li>
        <li><a href="#240106-所有权-ownership"><strong>240106 所有权 Ownership</strong></a>
          <ul>
            <li><a href="#变量和数据交互的方式">变量和数据交互的方式</a></li>
            <li><a href="#函数所有权">函数、所有权</a></li>
            <li><a href="#返回值与作用域">返回值与作用域</a></li>
            <li><a href="#悬空引用-dangling-reference">悬空引用 Dangling Reference：</a></li>
          </ul>
        </li>
        <li><a href="#240106-结构体-struct"><strong>240106 结构体 Struct</strong></a>
          <ul>
            <li><a href="#结构体">结构体</a></li>
            <li><a href="#struct方法">struct方法</a></li>
            <li><a href="#方法调用的运算符">方法调用的运算符</a></li>
            <li><a href="#关联函数">关联函数</a></li>
          </ul>
        </li>
        <li><a href="#241006-枚举与模式匹配"><strong>241006 枚举与模式匹配</strong></a>
          <ul>
            <li><a href="#枚举">枚举</a></li>
            <li><a href="#option枚举">Option枚举</a></li>
            <li><a href="#控制流运算符match">控制流运算符match</a></li>
            <li><a href="#匹配optiont">匹配Option&lt;T&gt;</a></li>
            <li><a href="#if-let">if let</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h3 id="240105-安装和简单上手" class="headerLink">
    <a href="#240105-%e5%ae%89%e8%a3%85%e5%92%8c%e7%ae%80%e5%8d%95%e4%b8%8a%e6%89%8b" class="header-mark"></a><strong>240105 安装和简单上手</strong></h3><h4 id="安装" class="headerLink">
    <a href="#%e5%ae%89%e8%a3%85" class="header-mark"></a>安装</h4><p>官网直接下载安装即可，有如下命令行可以使用：</p>
<ul>
<li>
<p>rustup updat更新版本</p>
</li>
<li>
<p>rustup self uninstall卸载</p>
</li>
<li>
<p>使用 rustc &ndash;version查看rust版本</p>
<a class="lightgallery" href="/image/Rust-01-Version.png" title="/image/Rust-01-Version.png" data-thumbnail="/image/Rust-01-Version.png">
            <img
                
                loading="lazy"
                src="/image/Rust-01-Version.png"
                srcset="/image/Rust-01-Version.png, /image/Rust-01-Version.png 1.5x, /image/Rust-01-Version.png 2x"
                
                alt="/image/Rust-01-Version.png" height="40%"  width="40%" >
        </a>
</li>
<li>
<p>包含本地文档，使用 rustup doc查看本地文档</p>
</li>
</ul>
<h4 id="开发工具与代码手动编译" class="headerLink">
    <a href="#%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%e4%b8%8e%e4%bb%a3%e7%a0%81%e6%89%8b%e5%8a%a8%e7%bc%96%e8%af%91" class="header-mark"></a>开发工具与代码手动编译</h4><ul>
<li>使用vscode作为开发工具，下载Rust插件作为辅助工具</li>
<li>代码文件名后缀为.rs，代码需要编译，使用rustc 文件名.rc进行编译，成功后出现exe文件和pdb文件（包含调试信息），执行exe即可运行程序</li>
<li>main是程序最先运行的函数，缩进为四个空格，println!是一个宏</li>
<li>rust程序是预编译程序，其他电脑运行程序时不需要下载rust</li>
</ul>
<h4 id="cargo" class="headerLink">
    <a href="#cargo" class="header-mark"></a>Cargo</h4><ul>
<li>Cargo是rust的构建系统和包管理工具，安装rusrt时同时安装，使用cargo &ndash;version命令确认安装</li>
<li>cargo new 项目名称：创建项目，完成后创建文件夹，包含toml配置文件和src源码文件，同时初始化了一个git仓库（gitignore文件）</li>
<li>toml里包含项目的相关信息（package信息块下），和其他的crate的依赖</li>
<li>自己手动写出来这几个文件也相当于手动创建了项目</li>
<li>cargo build用于构建项目（编译），会在target目录下创建可执行文件和cargo.lock文件负责追踪版本</li>
<li>cargo run用于直接构建和运行项目，如果编译过且未修改则直接运行</li>
<li>cargo check用于检查代码而不产生可执行文件，该命令速度比build快很多，可以连续使用来检查</li>
<li>cargo build &ndash;release用于发布文件，产生的可执行文件在release目录下</li>
</ul>
<h4 id="猜数游戏代码" class="headerLink">
    <a href="#%e7%8c%9c%e6%95%b0%e6%b8%b8%e6%88%8f%e4%bb%a3%e7%a0%81" class="header-mark"></a>猜数游戏代码</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">std</span>::<span class="n">io</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Guess a number&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">guess</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">new</span><span class="p">();</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// let定义，默认不可变，mut表示可变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// String是utf-8编码，可以根据需求扩展大小；::new是关联函数，针对类型本身（而不是实例），相当于类函数或静态方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">io</span>::<span class="n">stdin</span><span class="p">().</span><span class="n">read_line</span><span class="p">(</span><span class="cp">$mut</span><span class="w"> </span><span class="n">guess</span><span class="p">).</span><span class="n">expect</span><span class="p">(</span><span class="s">&#34;Unreadable&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// $是取值符，参数以引用传递，在代码的不同位置使用同一块地址，默认引用也不可变，使用mut使其可变
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// io::Result是一个枚举类型，有OK和Err两种类型，当返回OK时提取数据并赋值，返回Err时则中断程序并执行expect内容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="s">&#34;The number you guessed is {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">guess</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ul>
<li>crates.io/crate是Rust的仓库，crate是由源代码文件组成，有两种，包括二进制的可以行crate和不可执行的library crate（库包）</li>
<li>在cargo.toml中修改dependencies即可下载，比如rand=&ldquo;0.3.14&rdquo;，表示下载该版本；版本号前也可以加^表示公共兼容该版本的任意版本；下载后第一次build会编译你下载的依赖，并将其写在cargo.lock文件，并将其锁定，避免重复搜索、下载，同时保证编译的可重复性</li>
<li>ctrl+shift+P，搜索rust可以开启或关闭rust服务器，从而打开自动下载或关闭</li>
<li>cargo update命令运行时会忽略cargo.lock，重新从网络抓取可使用的、最新版本的包，并将其重新下载、编译和写入cargo.lock文件</li>
</ul>
<h3 id="240106-通用编程概念" class="headerLink">
    <a href="#240106-%e9%80%9a%e7%94%a8%e7%bc%96%e7%a8%8b%e6%a6%82%e5%bf%b5" class="header-mark"></a><strong>240106 通用编程概念</strong></h3><h4 id="变量与可变性" class="headerLink">
    <a href="#%e5%8f%98%e9%87%8f%e4%b8%8e%e5%8f%af%e5%8f%98%e6%80%a7" class="header-mark"></a>变量与可变性</h4><ul>
<li>声明变量需要使用let关键字</li>
<li>数据默认不可变，需要使用mut关键字指定可变类型</li>
<li>constant和不可变变量式不一样的，其永远不可变，定义时类型必须标注，可以在任意作用域内声明，只可以绑定到常量表达式而不可以是函数调用结果或运算时才计算的值，命名需要全部大写字母加下划线，常量在运行期间在作用域内一直有效</li>
<li>常量数字的字面量中可以使用下划线增强可读性</li>
</ul>
<h4 id="shadowing隐藏" class="headerLink">
    <a href="#shadowing%e9%9a%90%e8%97%8f" class="header-mark"></a>shadowing（隐藏）</h4><ul>
<li>
<p>使用相同的变量名，隐藏之前的变量，此时可以更改变量的类型</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 不合法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">//合法，隐藏之前的变量，x之后代表全新的变量
</span></span></span></code></pre></div></li>
<li>
<p>使用usize.len()返回字符串的长度</p>
</li>
</ul>
<h4 id="数据类型" class="headerLink">
    <a href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" class="header-mark"></a>数据类型</h4><ul>
<li>
<p>数据类型包含标量和复合类型两种：</p>
</li>
<li>
<p>标量是指一个单独的值，包含整数、浮点、布尔、字符</p>
<ul>
<li>整数：无符号u32 0到2^32-1 / 含符号i32是指-2^32+1到2^32-1/i64，除byte外都可以标注类型后缀，整数默认i32；可以十进制、八进制、十六进制；在编译模式下整数溢出会报错，发布模式下则会顺延，256u8是0、257u8是1；usize是无符号的根据系统位数决定的类型</li>
<li>浮点：f32、f64，IEEE-754标准，默认f64</li>
<li>数值操作：+、-、*、/、取余%</li>
<li>布尔：占用一个字节，true或false</li>
<li>字符（char）：单个字符，单引号，4个字节，unicode标量值，可以是多种语言的字符或emoji
​</li>
</ul>
</li>
<li>
<p>复合类型是多种类型在一起，Rust提供两种符合类型：</p>
<ul>
<li>元组Tuple：可以多个类型的多个值、长度固定、不可修改；(元素1, 元素2, ……)来定义；使用模式匹配来解构destructure元组的元素值 let (x, y, z) = tulpe；使用点标记法获取元素值，tuple.0，tuple.1……</li>
<li>数组：多个值在一个类型里，类型相同，长度不可变；使用中括号，逗号分开；有利于栈存放或固定数量元素；但是没有Vector类型灵活（vector由标准库提供，数组由prelude提供），Vector长度可变；let a[i32, 5] = [1,2,3,4,5]来声明，注意数组的格式书写方法，let b[3,5]相当于[5,5,5,5,5]；使用中括号索引；数组访问超出索引范围，编译有时会通过，运行时报错（Rust不允许连续访问其他相应地址的内存）</li>
</ul>
</li>
<li>
<p>rust是静态编译语言，即在编译时需要知道变量的全部的变量类型；编译器可以根据写的数字自动推断变量的类型；但对于多种可能时，需要指定，比如parse()方法返回的具体类型可以是多种</p>
</li>
</ul>
<h4 id="函数" class="headerLink">
    <a href="#%e5%87%bd%e6%95%b0" class="header-mark"></a>函数</h4><ul>
<li>
<p>main函数是程序的入口；Rust使用snack case命名规范；函数声明可以在运行之后（不像C只能在运行之前）
​</p>
</li>
<li>
<p>函数的参数：parameters是形参，arguements是实参；在函数定义的签名里，必须指定参数的类型
​</p>
</li>
<li>
<p>Rust是一个基于表达式的语言，语句是执行一些动作的指令，表达式是可以产生值的运算，语句没有返回值，所以不可以用于变量赋值；而函数体由一系列语句组成，可选的由一个表达式结束</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="c1">//是表达式，可以作为x的赋值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="err">；</span><span class="c1">//是语句，返回值为一个空元组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<ul>
<li>函数的返回值不可以命名，在箭头 -&gt; 符号的后面指定类型，默认最后一个表达式为返回值，提前返回时需要使用return关键字</li>
</ul>
<h4 id="注释" class="headerLink">
    <a href="#%e6%b3%a8%e9%87%8a" class="header-mark"></a>注释</h4><p>​使用//表示单行注释；另一种注释为文档注释</p>
<h4 id="控制流程" class="headerLink">
    <a href="#%e6%8e%a7%e5%88%b6%e6%b5%81%e7%a8%8b" class="header-mark"></a>控制流程</h4><p>条件判断：</p>
<ul>
<li>
<p>if 表达式，条件必须是bool（不会发生自动类型转化），对应不同的arm</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">()</span><span class="w"> </span><span class="c1">// 顺序执行, 会执行这一个arm，而不是下面整除2的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">%</span><span class="mi">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">peintln!</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>if是表达式，可以写在let的右边；但是要求if和else的类型必须相同，类型安全！</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<p>Rust提供了3种循环：</p>
<ul>
<li>
<p>loop循环，一直执行到喊停为止，可以使用break停止或ctrl+C手动停止；下面的案例注意break后面的表达式和分号</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">counter</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">break</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>while条件循环，每次执行前判断，</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">!&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">number</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;LIFTOFF!&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>for循环遍历集合，iter返回迭代器，element相当于一个指针</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">iter</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="n">element</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>range由标准库提供，可以生成他们之间的数字，左闭右开，rev可以反转range</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">for</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="p">).</span><span class="n">rev</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">println</span><span class="p">(</span><span class="n">number</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h3 id="240106-所有权-ownership" class="headerLink">
    <a href="#240106-%e6%89%80%e6%9c%89%e6%9d%83-ownership" class="header-mark"></a><strong>240106 所有权 Ownership</strong></h3><ul>
<li>
<p>所有权是Rust最独特的特性，他让rust无需GC（垃圾收集器）就可以保证内存安全；所有程序在运行时都需要管理他们的内存使用方式，有些语言使用垃圾收集，也有些语言需要程序员显式地声明；而Rust使用了所有权机制来进行管理</p>
</li>
<li>
<p>Stack 栈内存 vs Heap 堆内存：stack和heap都是可用的内存，但其存储方式不一样，stack式先进后出（Last in first out），存储过程叫做压栈，stack必须拥有已知的固定大小（编译时大小未知或运行时大小可能变化的数据只能在Heap）；Heap的内存组织性查一点，使用时系统在内存中找到一块足够大的空间，标记为在用并返回指针，即分配内存；而指针大小是一样的，所以可以将指针放在stack；存储和访问Heap的速度都较stack慢，因为内存空间存在跳转，需要利用指针调用</p>
</li>
<li>
<p>所有权解决的问题：</p>
<ol>
<li>跟踪代码哪些部分在使用Heap的哪些数据</li>
<li>最小化Heap上的重复数据</li>
<li>清理Heap上未使用的数据以避免空间不足；在学会所有权后则不需要频繁思考stack和heap问题</li>
</ol>
</li>
<li>
<p>所有权的3条规则：</p>
<ol>
<li>每个值都有一个变量，这个变量是该值的所有者</li>
<li>每个值同时只能有一个所有者</li>
<li>当所有者超出作用域scope时，该值将被<text style="color:maroon"><strong>删除</strong></text></li>
</ol>
</li>
<li>
<p>作用域是程序中一个项目的有效范围</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// s不可用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// s可用，可以对s进行相关操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w"> </span><span class="c1">// 离开作用域，s不再可用
</span></span></span></code></pre></div></li>
</ul>
<p><strong>举例</strong></p>
<ul>
<li>
<p>字符串字面值是程序中写好的那些字符串值，是不可变的，是硬编码到最终的可执行文件中的，其快速、高效</p>
</li>
<li>
<p>而Rust提供另一种字符串，叫做String，是在运行期间可变的，存储在heap上；变量离开作用域时，会自动调用drop() ，从而将内存空间清空返还给操作系统</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w"> </span><span class="c1">//使用from在函数运行时请求内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">s</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34;, world&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">println</span><span class="p">(</span><span class="s">&#34;{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h4 id="变量和数据交互的方式" class="headerLink">
    <a href="#%e5%8f%98%e9%87%8f%e5%92%8c%e6%95%b0%e6%8d%ae%e4%ba%a4%e4%ba%92%e7%9a%84%e6%96%b9%e5%bc%8f" class="header-mark"></a>变量和数据交互的方式</h4><ul>
<li>
<p><strong>移动（Move）</strong>：多个变量可以与同一个数据使用一种独特的方式来交互，例如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="c1">// 变量5绑定到变量x上
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="c1">// 创建了一个x的副本，绑定到变量y上
</span></span></span><span class="line"><span class="cl"><span class="c1">// 此时两个整数（固定大小）都被压到stack中
</span></span></span></code></pre></div></li>
<li>
<p>一个String由三部分组成：指向存放数据内容的指针、长度（len，字符串内容所需要的字节数）、容量（capacity是指String从操作系统总共获得内存的总字节数），这三个信息是固定大小，存放在stack上，而字符串的内容则在heap上</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>当把s1赋值给s2时，String在stack上的信息复制了一份，但heap上的信息则没有被复制；当变量离开作用域时，Rust上自动调用drop()函数，将heap上的内存释放；当s1和s2离开时，如果没有处理机制就会产生二次释放Double Free Bug（第二次释放的空间可能已经是别的信息了）</p>
</li>
<li>
<p>而在Rust中，s2产生时不会复制被分配的内存，而是让s1失效，这样s1离开作用域后，就不会释放任何东西；如果在失效后再次使用，就会报如下的编译错误：</p>
<p><figure><a class="lightgallery" href="/image/Rust-01-Ownership-BorrowAfterMove.png" title="img" data-thumbnail="/image/Rust-01-Ownership-BorrowAfterMove.png">
        <img
            
            loading="lazy"
            src="/image/Rust-01-Ownership-BorrowAfterMove.png"
            srcset="/image/Rust-01-Ownership-BorrowAfterMove.png, /image/Rust-01-Ownership-BorrowAfterMove.png 1.5x, /image/Rust-01-Ownership-BorrowAfterMove.png 2x"
            
            alt="/image/Rust-01-Ownership-BorrowAfterMove.png" height="515"  width="2312" >
    </a></figure></p>
</li>
<li>
<p>浅拷贝：像是String只复制stack上指针等信息的操作；深拷贝则是指同时复制指针和数据；rust在浅拷贝的基础上还是得原变量失效，这两个操作合起来叫做移动（move）</p>
</li>
<li>
<p>Rust的设计原则之一：不会自动创建数据的深拷贝（就运行时性能而言，任何自动赋值的操作都是廉价的）</p>
</li>
<li>
<p><strong>克隆（clone）</strong>：Rust上所谓的深拷贝，既复制heap又赋值stack；这种方法相对而言更消耗资源；let s2 = s1.clone()</p>
</li>
</ul>
<ul>
<li>
<p><strong>复制（copy）</strong>：对于整数这种固定大小的类型，其数据本身保存在stack上，在二次赋值之后，就会发生一个直接拷贝（因为不在heap上，所以无关乎深浅拷贝的问题，其都会发生一次stack上的复制）；如果一个类型实现了copy这个trait（trait可以暂时理解为接口），那么旧的变量在赋值后仍旧可用；如果一个类型或该类型的一部分实现了drop trait，rust就不允许它再去实现copy trait；任何简单标量的组和类型都是可以copy的，如u32、bool、char、f64、字段都可以copy的Tuple；任何需要分配内存或某种资源的都不是可copy的</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">, </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="c1">// x和y都是有效的
</span></span></span></code></pre></div></li>
</ul>
<h4 id="函数所有权" class="headerLink">
    <a href="#%e5%87%bd%e6%95%b0%e6%89%80%e6%9c%89%e6%9d%83" class="header-mark"></a>函数、所有权</h4><ul>
<li>
<p>在语义上，将值传递给函数和把值赋给变量是类似的；将值传递给函数会发生移动或复制</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">take_ownership</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;s: </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w"> </span><span class="c1">//发生移动后s失效，会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">make_copy</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;x: </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">//发生复制，some_number被drop不影响x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">take_ownership</span><span class="p">(</span><span class="n">some_string</span>: <span class="nb">String</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">some_string</span><span class="p">);}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">make_copy</span><span class="p">(</span><span class="n">some_number</span>: <span class="kt">i32</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">some_number</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h4 id="返回值与作用域" class="headerLink">
    <a href="#%e8%bf%94%e5%9b%9e%e5%80%bc%e4%b8%8e%e4%bd%9c%e7%94%a8%e5%9f%9f" class="header-mark"></a>返回值与作用域</h4><ul>
<li>
<p>函数在返回值的过程中同样会发生所有权的转移；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">give_ownership</span><span class="p">();</span><span class="w"> </span><span class="c1">// 把函数的返回值移动给s
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">give_ownership</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">String</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">some_string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">some_string</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>一个变量的所有权总会遵循同样的模式：把一个值赋给其他变量时会发生移动；当一个包含heap数据的变量离开作用域时，它的值会被drop函数清理，除非数据的所有权移动到了另一个变量上</p>
</li>
<li>
<p>NEXT QUESTION：如何让函数使用某个值，但不获得其所有权？</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_length</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 为了能够留住s1值的所有权，需要函数在使用后将其所有权再次返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The length of </span><span class="si">{}</span><span class="s"> is </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>另一种解决办法叫做<strong>引用</strong>（Reference）</p>
</li>
<li>
<p>在变量名前加上&amp;符号，表示引用，即允许你引用某些值而不获得其所有权</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span><span class="w"> </span><span class="c1">//&amp;s1指向了s1的值，但其不拥有s1，引用被清理，其指向数据不会被清除
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The length of </span><span class="si">{}</span><span class="s"> is </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>以引用方式获得函数参数的行为叫做<strong>借用</strong>（borrow），借用的东西是不可修改的；引用默认也是不可修改的，使用mut关键字改为可变引用；</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s1</span><span class="p">);</span><span class="w"> </span><span class="c1">//这里是可变引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The length of </span><span class="si">{}</span><span class="s"> is </span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">push_str</span><span class="p">(</span><span class="s">&#34;, world&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>可变引用的限制：在特定作用域内，对某一块数据，只能有一个可变的引用，防止数据竞争！可以通过创建新的作用域，来允许非同时的创建多个可变引用；此外，不可以同时拥有一个可变引用和一个不可变引用；但是可以同时存在多个不可变引用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h4 id="悬空引用-dangling-reference" class="headerLink">
    <a href="#%e6%82%ac%e7%a9%ba%e5%bc%95%e7%94%a8-dangling-reference" class="header-mark"></a>悬空引用 Dangling Reference：</h4><ul>
<li>
<p>悬空指针是指一个引用了内存中某个地址，但这块内存可能已经释放并分配给其他人使用了，此时读取的数据是不正确的；而在Rust中，编译器可以保证引用永远不是悬空引用，即如果引用了某些数据，编译器将保证在引用离开作用域前数据不会离开作用域</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dangle</span><span class="p">();</span><span class="w"> </span><span class="c1">// 报错缺少生命周期的说明符
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">dangle</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">String</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">&amp;</span><span class="n">s</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>引用的规则：</p>
<ol>
<li>在任何给定的时刻，只能满足下列条件之一：
<ol>
<li>一个可变的引用</li>
<li>任意数量不可变的引用</li>
</ol>
</li>
<li>引用必须一致有效</li>
</ol>
</li>
<li>
<p>切片（slice）是另一种不持有所有权的数据类型，再本质上是一种不可变引用（字符串字面值本质上就是字符串切片）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">11</span><span class="p">];</span><span class="w"> </span><span class="c1">//左闭右开，字符串切片，指向字符串的一部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="mi">5</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">whole</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="p">];</span><span class="w"> </span><span class="c1">// 语法糖
</span></span></span></code></pre></div></li>
<li>
<p>Question：编写一个函数，接受字符串作为参数，返回其中的第一个单词，如果没有任何空格，则返回整个字符串</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">word_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_word</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">word_index</span><span class="p">);</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// word_index和s之间没有硬绑定关系，在s发生改变后，word_index已经失去了原有的意义，但在当前的程序中并不会体现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span>:<span class="kp">&amp;</span><span class="nc">Sting</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">();</span><span class="w"> </span><span class="c1">//将String转变为一个数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">bytes</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">enumerate</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sa">b</span><span class="sc">&#39; &#39;</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">retrun</span><span class="w"> </span><span class="n">i</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Hello world&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">word_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first_word</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span><span class="w"> </span><span class="c1">// 因为word_index绑定了s的不可变引用，s不可以再修改了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">word_index</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span>:<span class="kp">&amp;</span><span class="nc">Sting</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="kt">str</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">as_bytes</span><span class="p">();</span><span class="w"> </span><span class="c1">//将String转变为一个数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">bytes</span><span class="p">.</span><span class="n">iter</span><span class="p">().</span><span class="n">enumerate</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sa">b</span><span class="sc">&#39; &#39;</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">retrun</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="n">i</span><span class="p">]</span><span class="err">；</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="p">]</span><span class="w"> </span><span class="c1">// 返回的切片是s的不可变引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p>将字符串切片作为参数传递相比于字符串引用更好，因为&amp;str可以同时接受String类型（制作一个完整切片传入即可 string[..]）或&amp;str类型数据，可以使API更加通用且不损失任何功能</p>
</li>
<li>
<p>除字符串外，还存在一些其他类型的切片，如</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">slice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">];</span><span class="w"> </span><span class="c1">//slice是&amp;[i32]类型
</span></span></span></code></pre></div></li>
</ul>
<h3 id="240106-结构体-struct" class="headerLink">
    <a href="#240106-%e7%bb%93%e6%9e%84%e4%bd%93-struct" class="header-mark"></a><strong>240106 结构体 Struct</strong></h3><h4 id="结构体" class="headerLink">
    <a href="#%e7%bb%93%e6%9e%84%e4%bd%93" class="header-mark"></a>结构体</h4><ul>
<li>
<p><strong>结构体</strong>是自定义的数据类型，为相关联的值命名打包，成为有意义的组合；使用struct关键字命名，在花括号内列出所有字段，定义名称和类型；使用时需要实例化，指定具体的值（无需按照声明的顺序指定）；使用点标记法访问字段；结构体内参数如果需要修改，需要指定整个结构体为mut类型，不允许仅部分字段可变；结构体可以作为函数的返回值；当字段名和变量名一致时可以简写为一个；如果想要基于某个struct实例创建一个新的实例时，可以使用struct的更新语法</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">mut</span><span class="w"> </span><span class="n">User</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">username</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">email</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">sign_in_count</span>: <span class="kt">u64</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">active</span>: <span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="c1">//注意这里也有逗号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">user1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">User</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">email</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;abc@126.com&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">username</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;Nikky&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">active</span>: <span class="nc">true</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">sign_in_count</span>: <span class="mi">556</span><span class="p">,</span><span class="w"> </span><span class="c1">//数据不能少
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">};</span><span class="w"> </span><span class="c1">//记得这里的分号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">user1</span><span class="p">.</span><span class="n">email</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;123&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//更新语法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">User</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">email</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;another@example.com&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">username</span>: <span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;567&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">..</span><span class="n">user1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>Tuple Struct</strong>：类似tuple的struct，整体有名，但里面的字段没有名</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Color</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">Point</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">black</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">orgin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Point</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// black和orgin是不同的类型
</span></span></span></code></pre></div></li>
<li>
<p><strong>Unit-Like Struct</strong>（没有任何字段的结构体）：与空元组()类似，适用于在某个类型上实现某个trait，但在里面有没有想要存储的数据</p>
</li>
<li>
<p>关于结构体的<strong>所有权</strong>：在上面User的案例中，其使用了String类型，而不是&amp;str，因而该结构体拥有其所有数据的所有权，只要strcut实例是有效的，里面的字段也就是有效的；而当struct里存放引用，需要考虑生命周期问题</p>
</li>
<li>
<p>如果需要打印struct，需要实现display()这个trait，可以使用<code>{:?}</code>/<code>{:#?}</code>和<code>#[derive(Debug)]</code>进行扩展显示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[derive(Debug)]</span><span class="w"> </span><span class="c1">//注解，一种格式化的方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">width</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">length</span>: <span class="kt">u32</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">rect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">width</span>: <span class="mi">30</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">length</span>: <span class="mi">50</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">area</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{:?}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">rect</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="n">rect</span>: <span class="kp">&amp;</span><span class="nc">Rectangle</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">rect</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rect</span><span class="p">.</span><span class="n">length</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h4 id="struct方法" class="headerLink">
    <a href="#struct%e6%96%b9%e6%b3%95" class="header-mark"></a>struct方法</h4><ul>
<li>
<p>方法和函数类似，具有fn关键字、名称、参数、返回值；不同之处：方法是在struct的上下文中定义（impl块中），第一个参数可以是&amp;self，表示方法被调用的struct实例（和其他参数一样，也可以获得其所有权或可变借用）；每个Struct可以拥有多个impl块</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">impl</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u32</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">length</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;</span><span class="si">{}</span><span class="s">&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">rect</span><span class="p">.</span><span class="n">area</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h4 id="方法调用的运算符" class="headerLink">
    <a href="#%e6%96%b9%e6%b3%95%e8%b0%83%e7%94%a8%e7%9a%84%e8%bf%90%e7%ae%97%e7%ac%a6" class="header-mark"></a>方法调用的运算符</h4><ul>
<li>在C/C++中，可以是对象.方法，如果是一个指针，可以是obj -&gt; something() ，其含义等同于 (<em>obj).something；而Rust中-&gt;表示返回值，不是指针对象上的方法，在方法调用时，其提供自动引用或解引用，即是说，在调用方法时，Rust会自动根据情况添加&amp;、&amp;mut或</em>，以便object可以匹配方法的签名</li>
</ul>
<h4 id="关联函数" class="headerLink">
    <a href="#%e5%85%b3%e8%81%94%e5%87%bd%e6%95%b0" class="header-mark"></a>关联函数</h4><ul>
<li>在impl块里还可以定义第一个参数不是self的函数，注意其不是方法，不依赖于实例调用，例如String::from()，通常用于构造器</li>
</ul>
<h3 id="241006-枚举与模式匹配" class="headerLink">
    <a href="#241006-%e6%9e%9a%e4%b8%be%e4%b8%8e%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d" class="header-mark"></a><strong>241006 枚举与模式匹配</strong></h3><h4 id="枚举" class="headerLink">
    <a href="#%e6%9e%9a%e4%b8%be" class="header-mark"></a>枚举</h4><ul>
<li>
<p>枚举允许我们列举所有可能的值来定义一个类型，使用enum关键字定义，列举的可能性被称为枚举变体</p>
</li>
<li>
<p>枚举变体位于标识符的命名空间下，使用两个冒号::分割；枚举类型是一种自定义的数据类型，可以作为结构体内的字段</p>
</li>
<li>
<p>此外，Rust允许将数据直接附加到枚举的变体中，此时就不需要额外再使用struct，每个变体可以拥有不同的类型及其关联的数据量</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">IpAddrKind</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">V4</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">V6</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">IpAddr</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">kind</span>: <span class="nc">IpAddrKind</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">address</span>: <span class="nb">String</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">four</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddrKind</span>::<span class="n">V4</span><span class="p">;</span><span class="w"> </span><span class="c1">//创建枚举值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">six</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddrKind</span>::<span class="n">V6</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">route</span><span class="p">(</span><span class="n">four</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">route</span><span class="p">(</span><span class="n">IpAddrKind</span>::<span class="n">V4</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">route</span><span class="p">(</span><span class="n">ip_kind</span>:<span class="nc">IpAddrKind</span><span class="p">){</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">IpAddrKind</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">V4</span><span class="p">(</span><span class="kt">u8</span><span class="p">,</span><span class="kt">u8</span><span class="p">,</span><span class="kt">u8</span><span class="p">,</span><span class="kt">u8</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">V6</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">home</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddrKind</span>::<span class="n">V4</span><span class="p">(</span><span class="mi">127</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">//创建枚举值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">six</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IpAddrKind</span>::<span class="n">V6</span><span class="p">(</span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">&#34;::1&#34;</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">route</span><span class="p">(</span><span class="n">ip_kind</span>:<span class="nc">IpAddrKind</span><span class="p">){</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h4 id="option枚举" class="headerLink">
    <a href="#option%e6%9e%9a%e4%b8%be" class="header-mark"></a>Option枚举</h4><ul>
<li>
<p>定义域标准库中，在prelude中，描述了某个值可能存在（某种类型）或不存在的情况；</p>
</li>
<li>
<p>在其他语言中，Null是一个值，表示“没有值”，即是说一个变量可以处于两种状态，空或非空；而在Rust中，没有Null的概念（Null引用是一个Billion Dallar Mistake），其问题在于，当你像使用非空值那样来使用null值时，就会引起错误；但其概念仍旧是有意义的，其表示因某种原因而变为无效或缺失的值；</p>
</li>
<li>
<p>在Rust中，为了解决Null问题，提供了一个类似Null概念的枚举，叫做Option<T>，其在标准库中的定义如下，其中<T>表示泛型参数；这种设计的好处在于Option<T>和T不是同一类型，在使用时，必须进行转换，这就强制要求程序员解决值不存在的情况</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h4 id="控制流运算符match" class="headerLink">
    <a href="#%e6%8e%a7%e5%88%b6%e6%b5%81%e8%bf%90%e7%ae%97%e7%ac%a6match" class="header-mark"></a>控制流运算符match</h4><ul>
<li>
<p>允许一个值与一系列模式进行匹配，并执行匹配到模式的对应代码；这些模式可以是字面值、变量名、通配符；需要注意的是，Match表达式需要穷举所有的格式匹配，如果不想细致书写，可以使用通配符_表示余下的可能</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[derive(Debug)]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">enum</span> <span class="nc">UsState</span><span class="p">{</span><span class="w"> </span><span class="n">Alabama</span><span class="p">,</span><span class="w"> </span><span class="n">Alaska</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">enum</span> <span class="nc">Coin</span><span class="p">{</span><span class="w"> </span><span class="n">Penny</span><span class="p">,</span><span class="w"> </span><span class="n">Nickel</span><span class="p">,</span><span class="w"> </span><span class="n">Dime</span><span class="p">,</span><span class="w"> </span><span class="n">Quarter</span><span class="p">(</span><span class="n">UsState</span><span class="p">),</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">value_in_cents</span><span class="p">(</span><span class="n">coin</span>:<span class="nc">Coin</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">u8</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">coin</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Coin</span>::<span class="n">Penny</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;1&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Coin</span>::<span class="n">Nickel</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Coin</span>::<span class="n">Dime</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Coin</span>::<span class="n">Quarter</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">println</span><span class="p">(</span><span class="s">&#34;{:?}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="mi">25</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<h4 id="匹配optiont" class="headerLink">
    <a href="#%e5%8c%b9%e9%85%8doptiont" class="header-mark"></a>匹配Option&lt;T&gt;</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">pulse_one</span><span class="p">(</span><span class="n">x</span>:<span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Option</span><span class="o">&lt;</span><span class="kt">i32</span><span class="o">&gt;</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">None</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="if-let" class="headerLink">
    <a href="#if-let" class="header-mark"></a>if let</h4><p>-​ <strong>if let</strong>是一种简单的控制流，其处理只关心一种匹配而忽略其他匹配的情况（放弃了穷举的可能，可以看作是match的语法糖）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">match</span><span class="w"> </span><span class="n">v</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;three&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;three&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;others!&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></div>

        <div class="sponsor">
        <div class="sponsor-avatar"><img
        
        loading="lazy"
        src="/avater.jpg"
        srcset="/avater.jpg, /avater.jpg 1.5x, /avater.jpg 2x"
        sizes="auto"
        alt="/avater.jpg"
        title="/avater.jpg" height="959"   width="959" ></div><p class="sponsor-bio"><em>如果你觉得这篇文章对你有帮助，欢迎赞赏~</em></p><a href="https://www.buymeacoffee.com/jwangl5" title="Sponsor" target="_blank" class="sponsor-button" rel="noopener noreferrer">
                <i class="far fa-heart fa-fw icon" style="color: #ec6cb9;"></i>
                <span>赞赏</span>
            </a></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2024-01-07</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/hp_printer/" class="prev" rel="prev" title="关于打印机的一些知识"><i class="fas fa-angle-left fa-fw"></i>关于打印机的一些知识</a>
            <a href="/posts/rust/rust_note_02/" class="next" rel="next" title="Rust | 02. 包管理、集合（String、Vector、HashMap）、泛型">Rust | 02. 包管理、集合（String、Vector、HashMap）、泛型<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
</article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2023 - 2024</span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh-hans" target="_blank">CC BY-NC-ND 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.css">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"></noscript><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":100},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"distance":100,"findAllMatches":false,"highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":false,"isCaseSensitive":false,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":50,"threshold":0.3,"useExtendedSearch":false},"table":{"sort":true}};</script><script type="text/javascript" src="/lib/tablesort/tablesort.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.js" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.js" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><script type="text/javascript" src="/js/theme.min.js" defer></script></div>
</body>

</html>